// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"time"
)

const addMovieToList = `-- name: AddMovieToList :exec
INSERT INTO
    list_movie (
        movie_id,
        list_id,
        date_added,
        position,
        note
    )
SELECT
    ?,
    ?,
    ?,
    ?,
    ?
FROM
    list
WHERE
    list.id = ?
    AND list.user_id = ?
`

type AddMovieToListParams struct {
	MovieID   int64
	ListID    int64
	DateAdded string
	Position  *int64
	Note      *string
	ID        int64
	UserID    *int64
}

func (q *Queries) AddMovieToList(ctx context.Context, arg AddMovieToListParams) error {
	_, err := q.db.ExecContext(ctx, addMovieToList,
		arg.MovieID,
		arg.ListID,
		arg.DateAdded,
		arg.Position,
		arg.Note,
		arg.ID,
		arg.UserID,
	)
	return err
}

const assignNilUserLists = `-- name: AssignNilUserLists :exec
UPDATE
    list
SET
    user_id = ?
WHERE
    user_id IS NULL
`

func (q *Queries) AssignNilUserLists(ctx context.Context, userID *int64) error {
	_, err := q.db.ExecContext(ctx, assignNilUserLists, userID)
	return err
}

const assignNilUserWatched = `-- name: AssignNilUserWatched :exec
UPDATE
    watched
SET
    user_id = ?
WHERE
    user_id IS NULL
`

func (q *Queries) AssignNilUserWatched(ctx context.Context, userID *int64) error {
	_, err := q.db.ExecContext(ctx, assignNilUserWatched, userID)
	return err
}

const countUsers = `-- name: CountUsers :one
SELECT
    COUNT(*)
FROM
    user
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :exec
INSERT INTO
    session (id, user_id, expires_at)
VALUES
    (?, ?, ?)
`

type CreateSessionParams struct {
	ID        string
	UserID    int64
	ExpiresAt time.Time
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.ExecContext(ctx, createSession, arg.ID, arg.UserID, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
    user (email, name, password_hash, created_at)
VALUES
    (?, ?, ?, datetime('now'))
RETURNING
    id, email, password_hash, name, created_at, admin, password_reset_required
`

type CreateUserParams struct {
	Email        string
	Name         string
	PasswordHash string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.Name, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.CreatedAt,
		&i.Admin,
		&i.PasswordResetRequired,
	)
	return i, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM
    session
WHERE
    expires_at <= datetime('now')
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredSessions)
	return err
}

const deleteListByID = `-- name: DeleteListByID :exec
DELETE FROM
    list
WHERE
    user_id = ?
    AND id = ?
`

type DeleteListByIDParams struct {
	UserID *int64
	ID     int64
}

func (q *Queries) DeleteListByID(ctx context.Context, arg DeleteListByIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteListByID, arg.UserID, arg.ID)
	return err
}

const deleteMovieFromList = `-- name: DeleteMovieFromList :exec
DELETE FROM
    list_movie
WHERE
    list_id = ?
    AND movie_id = ?
    AND EXISTS (
        SELECT
            1
        FROM
            list
        WHERE
            list.id = list_id
            AND list.user_id = ?
    )
`

type DeleteMovieFromListParams struct {
	ListID  int64
	MovieID int64
	UserID  *int64
}

func (q *Queries) DeleteMovieFromList(ctx context.Context, arg DeleteMovieFromListParams) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFromList, arg.ListID, arg.MovieID, arg.UserID)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM
    session
WHERE
    id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM
    user
WHERE
    id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getAllLists = `-- name: GetAllLists :many
SELECT
    id, name, creation_date, description, user_id, is_watchlist
FROM
    list
WHERE
    user_id = ?
`

func (q *Queries) GetAllLists(ctx context.Context, userID *int64) ([]List, error) {
	rows, err := q.db.QueryContext(ctx, getAllLists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []List
	for rows.Next() {
		var i List
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreationDate,
			&i.Description,
			&i.UserID,
			&i.IsWatchlist,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersWithStats = `-- name: GetAllUsersWithStats :many
SELECT
    u.id,
    u.email,
    u.name,
    u.created_at,
    u.admin,
    (
        SELECT
            COUNT(*)
        FROM
            watched w
        WHERE
            w.user_id = u.id
    ) AS watched_count,
    (
        SELECT
            COUNT(*)
        FROM
            list l
        WHERE
            l.user_id = u.id
    ) AS list_count
FROM
    user u
ORDER BY
    u.created_at DESC
`

type GetAllUsersWithStatsRow struct {
	ID           int64
	Email        string
	Name         string
	CreatedAt    *time.Time
	Admin        bool
	WatchedCount int64
	ListCount    int64
}

func (q *Queries) GetAllUsersWithStats(ctx context.Context) ([]GetAllUsersWithStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersWithStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersWithStatsRow
	for rows.Next() {
		var i GetAllUsersWithStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.CreatedAt,
			&i.Admin,
			&i.WatchedCount,
			&i.ListCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCastByMovieID = `-- name: GetCastByMovieID :many
SELECT
    movie_id, person_id, cast_id, credit_id, character, cast_order, updated_at
FROM
    cast
WHERE
    movie_id = ?
`

func (q *Queries) GetCastByMovieID(ctx context.Context, movieID int64) ([]Cast, error) {
	rows, err := q.db.QueryContext(ctx, getCastByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cast
	for rows.Next() {
		var i Cast
		if err := rows.Scan(
			&i.MovieID,
			&i.PersonID,
			&i.CastID,
			&i.CreditID,
			&i.Character,
			&i.CastOrder,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCrewByMovieID = `-- name: GetCrewByMovieID :many
SELECT
    movie_id, person_id, credit_id, job, department, updated_at
FROM
    crew
WHERE
    movie_id = ?
`

func (q *Queries) GetCrewByMovieID(ctx context.Context, movieID int64) ([]Crew, error) {
	rows, err := q.db.QueryContext(ctx, getCrewByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Crew
	for rows.Next() {
		var i Crew
		if err := rows.Scan(
			&i.MovieID,
			&i.PersonID,
			&i.CreditID,
			&i.Job,
			&i.Department,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListByID = `-- name: GetListByID :one
SELECT
    id, name, creation_date, description, user_id, is_watchlist
FROM
    list
WHERE
    user_id = ?
    AND id = ?
`

type GetListByIDParams struct {
	UserID *int64
	ID     int64
}

func (q *Queries) GetListByID(ctx context.Context, arg GetListByIDParams) (List, error) {
	row := q.db.QueryRowContext(ctx, getListByID, arg.UserID, arg.ID)
	var i List
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreationDate,
		&i.Description,
		&i.UserID,
		&i.IsWatchlist,
	)
	return i, err
}

const getListJoinMovieByID = `-- name: GetListJoinMovieByID :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline, movie.updated_at,
    list_movie.movie_id, list_movie.list_id, list_movie.date_added, list_movie.position, list_movie.note,
    list.id, list.name, list.creation_date, list.description, list.user_id, list.is_watchlist
FROM
    list
    JOIN list_movie ON list_movie.list_id = list.id
    JOIN movie ON movie.id = list_movie.movie_id
WHERE
    list.user_id = ?
    AND list.id = ?
`

type GetListJoinMovieByIDParams struct {
	UserID *int64
	ID     int64
}

type GetListJoinMovieByIDRow struct {
	Movie     Movie
	ListMovie ListMovie
	List      List
}

func (q *Queries) GetListJoinMovieByID(ctx context.Context, arg GetListJoinMovieByIDParams) ([]GetListJoinMovieByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getListJoinMovieByID, arg.UserID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListJoinMovieByIDRow
	for rows.Next() {
		var i GetListJoinMovieByIDRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Movie.UpdatedAt,
			&i.ListMovie.MovieID,
			&i.ListMovie.ListID,
			&i.ListMovie.DateAdded,
			&i.ListMovie.Position,
			&i.ListMovie.Note,
			&i.List.ID,
			&i.List.Name,
			&i.List.CreationDate,
			&i.List.Description,
			&i.List.UserID,
			&i.List.IsWatchlist,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyGenreBreakdown = `-- name: GetMonthlyGenreBreakdown :many
SELECT
    watched.watched_date,
    genre.name AS genre_name,
    COUNT(*) AS movie_count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
    JOIN genre_movie ON movie.id = genre_movie.movie_id
    JOIN genre ON genre_movie.genre_id = genre.id
WHERE
    watched.watched_date >= date('now', 'start of month', '-12 months')
    AND watched.user_id = ?
GROUP BY
    watched.watched_date,
    genre_name
ORDER BY
    watched.watched_date,
    movie_count DESC
`

type GetMonthlyGenreBreakdownRow struct {
	WatchedDate time.Time
	GenreName   string
	MovieCount  int64
}

func (q *Queries) GetMonthlyGenreBreakdown(ctx context.Context, userID *int64) ([]GetMonthlyGenreBreakdownRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyGenreBreakdown, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlyGenreBreakdownRow
	for rows.Next() {
		var i GetMonthlyGenreBreakdownRow
		if err := rows.Scan(&i.WatchedDate, &i.GenreName, &i.MovieCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedDay = `-- name: GetMostWatchedDay :many
SELECT
    watched_date
FROM
    watched
WHERE
    user_id = ?
`

func (q *Queries) GetMostWatchedDay(ctx context.Context, userID *int64) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedDay, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var watched_date time.Time
		if err := rows.Scan(&watched_date); err != nil {
			return nil, err
		}
		items = append(items, watched_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedFemaleActors = `-- name: GetMostWatchedFemaleActors :many
SELECT
    person.name,
    person.id,
    person.profile_path,
    person.gender,
    COUNT(*) AS watch_count
FROM
    watched
    JOIN "cast" ON watched.movie_id = "cast".movie_id
    JOIN person ON "cast".person_id = person.id
WHERE
    person.gender = 1
    AND watched.user_id = ?
GROUP BY
    person.id,
    person.name,
    person.profile_path,
    person.gender
ORDER BY
    watch_count DESC
LIMIT
    ?
`

type GetMostWatchedFemaleActorsParams struct {
	UserID *int64
	Limit  int64
}

type GetMostWatchedFemaleActorsRow struct {
	Name        string
	ID          int64
	ProfilePath string
	Gender      int64
	WatchCount  int64
}

func (q *Queries) GetMostWatchedFemaleActors(ctx context.Context, arg GetMostWatchedFemaleActorsParams) ([]GetMostWatchedFemaleActorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedFemaleActors, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostWatchedFemaleActorsRow
	for rows.Next() {
		var i GetMostWatchedFemaleActorsRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.ProfilePath,
			&i.Gender,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedMaleActors = `-- name: GetMostWatchedMaleActors :many
SELECT
    person.name,
    person.id,
    person.profile_path,
    person.gender,
    COUNT(*) AS watch_count
FROM
    watched
    JOIN "cast" ON watched.movie_id = "cast".movie_id
    JOIN person ON "cast".person_id = person.id
WHERE
    person.gender = 2
    AND watched.user_id = ?
GROUP BY
    person.id,
    person.name,
    person.profile_path,
    person.gender
ORDER BY
    watch_count DESC
LIMIT
    ?
`

type GetMostWatchedMaleActorsParams struct {
	UserID *int64
	Limit  int64
}

type GetMostWatchedMaleActorsRow struct {
	Name        string
	ID          int64
	ProfilePath string
	Gender      int64
	WatchCount  int64
}

func (q *Queries) GetMostWatchedMaleActors(ctx context.Context, arg GetMostWatchedMaleActorsParams) ([]GetMostWatchedMaleActorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedMaleActors, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostWatchedMaleActorsRow
	for rows.Next() {
		var i GetMostWatchedMaleActorsRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.ProfilePath,
			&i.Gender,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedMovies = `-- name: GetMostWatchedMovies :many
SELECT
    movie.title,
    movie.id,
    movie.poster_path,
    COUNT(*) AS watch_count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    watched.user_id = ?
GROUP BY
    movie.id,
    movie.title,
    movie.poster_path
ORDER BY
    watch_count DESC
LIMIT
    ?
`

type GetMostWatchedMoviesParams struct {
	UserID *int64
	Limit  int64
}

type GetMostWatchedMoviesRow struct {
	Title      string
	ID         int64
	PosterPath string
	WatchCount int64
}

func (q *Queries) GetMostWatchedMovies(ctx context.Context, arg GetMostWatchedMoviesParams) ([]GetMostWatchedMoviesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedMovies, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostWatchedMoviesRow
	for rows.Next() {
		var i GetMostWatchedMoviesRow
		if err := rows.Scan(
			&i.Title,
			&i.ID,
			&i.PosterPath,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieByID = `-- name: GetMovieByID :one
SELECT
    id, title, original_title, original_language, overview, release_date, poster_path, backdrop_path, popularity, vote_count, vote_average, budget, homepage, imdb_id, revenue, runtime, status, tagline, updated_at
FROM
    movie
WHERE
    id = ?
`

func (q *Queries) GetMovieByID(ctx context.Context, id int64) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByID, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.OriginalTitle,
		&i.OriginalLanguage,
		&i.Overview,
		&i.ReleaseDate,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Popularity,
		&i.VoteCount,
		&i.VoteAverage,
		&i.Budget,
		&i.Homepage,
		&i.ImdbID,
		&i.Revenue,
		&i.Runtime,
		&i.Status,
		&i.Tagline,
		&i.UpdatedAt,
	)
	return i, err
}

const getMovieGenre = `-- name: GetMovieGenre :many
SELECT
    id, name, genre.updated_at, movie_id, genre_id, genre_movie.updated_at
FROM
    genre
    JOIN genre_movie ON genre.id = genre_movie.genre_id
WHERE
    genre_movie.movie_id = ?
`

type GetMovieGenreRow struct {
	ID          int64
	Name        string
	UpdatedAt   *time.Time
	MovieID     int64
	GenreID     int64
	UpdatedAt_2 *time.Time
}

func (q *Queries) GetMovieGenre(ctx context.Context, movieID int64) ([]GetMovieGenreRow, error) {
	rows, err := q.db.QueryContext(ctx, getMovieGenre, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMovieGenreRow
	for rows.Next() {
		var i GetMovieGenreRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UpdatedAt,
			&i.MovieID,
			&i.GenreID,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerson = `-- name: GetPerson :one
SELECT
    id, name, original_name, profile_path, known_for_department, popularity, gender, adult, updated_at
FROM
    person
WHERE
    id = ?
`

func (q *Queries) GetPerson(ctx context.Context, id int64) (Person, error) {
	row := q.db.QueryRowContext(ctx, getPerson, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalName,
		&i.ProfilePath,
		&i.KnownForDepartment,
		&i.Popularity,
		&i.Gender,
		&i.Adult,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecentWatchedMovies = `-- name: GetRecentWatchedMovies :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline, movie.updated_at,
    watched.id, watched.movie_id, watched.user_id, watched.watched_date, watched.watched_in_theater, watched.rating
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    watched.user_id = ?
ORDER BY
    watched.watched_date DESC
LIMIT
    ?
`

type GetRecentWatchedMoviesParams struct {
	UserID *int64
	Limit  int64
}

type GetRecentWatchedMoviesRow struct {
	Movie   Movie
	Watched Watched
}

func (q *Queries) GetRecentWatchedMovies(ctx context.Context, arg GetRecentWatchedMoviesParams) ([]GetRecentWatchedMoviesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentWatchedMovies, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentWatchedMoviesRow
	for rows.Next() {
		var i GetRecentWatchedMoviesRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Movie.UpdatedAt,
			&i.Watched.ID,
			&i.Watched.MovieID,
			&i.Watched.UserID,
			&i.Watched.WatchedDate,
			&i.Watched.WatchedInTheater,
			&i.Watched.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT
    user_id,
    expires_at
FROM
    session
WHERE
    id = ?
    AND expires_at > datetime('now')
`

type GetSessionRow struct {
	UserID    int64
	ExpiresAt time.Time
}

func (q *Queries) GetSession(ctx context.Context, id string) (GetSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i GetSessionRow
	err := row.Scan(&i.UserID, &i.ExpiresAt)
	return i, err
}

const getTheaterVsHomeCount = `-- name: GetTheaterVsHomeCount :many
SELECT
    watched_in_theater,
    COUNT(*) AS count
FROM
    watched
WHERE
    user_id = ?
GROUP BY
    watched_in_theater
`

type GetTheaterVsHomeCountRow struct {
	WatchedInTheater bool
	Count            int64
}

func (q *Queries) GetTheaterVsHomeCount(ctx context.Context, userID *int64) ([]GetTheaterVsHomeCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getTheaterVsHomeCount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTheaterVsHomeCountRow
	for rows.Next() {
		var i GetTheaterVsHomeCountRow
		if err := rows.Scan(&i.WatchedInTheater, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalHoursWatched = `-- name: GetTotalHoursWatched :one
SELECT
    SUM(movie.runtime) AS total_minutes
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    movie.runtime > 0
    AND watched.user_id = ?
`

func (q *Queries) GetTotalHoursWatched(ctx context.Context, userID *int64) (*float64, error) {
	row := q.db.QueryRowContext(ctx, getTotalHoursWatched, userID)
	var total_minutes *float64
	err := row.Scan(&total_minutes)
	return total_minutes, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    id, email, password_hash, name, created_at, admin, password_reset_required
FROM
    user
WHERE
    email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.CreatedAt,
		&i.Admin,
		&i.PasswordResetRequired,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id, email, password_hash, name, created_at, admin, password_reset_required
FROM
    user
WHERE
    id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.CreatedAt,
		&i.Admin,
		&i.PasswordResetRequired,
	)
	return i, err
}

const getWatchedByGenre = `-- name: GetWatchedByGenre :many
SELECT
    genre.name,
    COUNT(*) AS count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
    JOIN genre_movie ON movie.id = genre_movie.movie_id
    JOIN genre ON genre_movie.genre_id = genre.id
WHERE
    watched.user_id = ?
GROUP BY
    genre.id,
    genre.name
ORDER BY
    count DESC
`

type GetWatchedByGenreRow struct {
	Name  string
	Count int64
}

func (q *Queries) GetWatchedByGenre(ctx context.Context, userID *int64) ([]GetWatchedByGenreRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedByGenre, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedByGenreRow
	for rows.Next() {
		var i GetWatchedByGenreRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedCount = `-- name: GetWatchedCount :one
SELECT
    COUNT(*) AS count
FROM
    watched
WHERE
    user_id = ?
`

func (q *Queries) GetWatchedCount(ctx context.Context, userID *int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getWatchedCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWatchedDateRange = `-- name: GetWatchedDateRange :one
SELECT
    MIN(watched_date) AS min_date,
    MAX(watched_date) AS max_date
FROM
    watched
WHERE
    watched_date IS NOT NULL
    AND user_id = ?
`

type GetWatchedDateRangeRow struct {
	MinDate interface{}
	MaxDate interface{}
}

func (q *Queries) GetWatchedDateRange(ctx context.Context, userID *int64) (GetWatchedDateRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getWatchedDateRange, userID)
	var i GetWatchedDateRangeRow
	err := row.Scan(&i.MinDate, &i.MaxDate)
	return i, err
}

const getWatchedDates = `-- name: GetWatchedDates :many
SELECT
    watched_date
FROM
    watched
WHERE
    user_id = ?
ORDER BY
    watched_date
`

func (q *Queries) GetWatchedDates(ctx context.Context, userID *int64) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedDates, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var watched_date time.Time
		if err := rows.Scan(&watched_date); err != nil {
			return nil, err
		}
		items = append(items, watched_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedJoinMovie = `-- name: GetWatchedJoinMovie :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline, movie.updated_at,
    watched.id, watched.movie_id, watched.user_id, watched.watched_date, watched.watched_in_theater, watched.rating
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    watched.user_id = ?
`

type GetWatchedJoinMovieRow struct {
	Movie   Movie
	Watched Watched
}

func (q *Queries) GetWatchedJoinMovie(ctx context.Context, userID *int64) ([]GetWatchedJoinMovieRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedJoinMovie, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedJoinMovieRow
	for rows.Next() {
		var i GetWatchedJoinMovieRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Movie.UpdatedAt,
			&i.Watched.ID,
			&i.Watched.MovieID,
			&i.Watched.UserID,
			&i.Watched.WatchedDate,
			&i.Watched.WatchedInTheater,
			&i.Watched.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedJoinMovieByID = `-- name: GetWatchedJoinMovieByID :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline, movie.updated_at,
    watched.id, watched.movie_id, watched.user_id, watched.watched_date, watched.watched_in_theater, watched.rating
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    watched.user_id = ?
    AND watched.movie_id = ?
ORDER BY
    watched.watched_date DESC
`

type GetWatchedJoinMovieByIDParams struct {
	UserID  *int64
	MovieID int64
}

type GetWatchedJoinMovieByIDRow struct {
	Movie   Movie
	Watched Watched
}

func (q *Queries) GetWatchedJoinMovieByID(ctx context.Context, arg GetWatchedJoinMovieByIDParams) ([]GetWatchedJoinMovieByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedJoinMovieByID, arg.UserID, arg.MovieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedJoinMovieByIDRow
	for rows.Next() {
		var i GetWatchedJoinMovieByIDRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Movie.UpdatedAt,
			&i.Watched.ID,
			&i.Watched.MovieID,
			&i.Watched.UserID,
			&i.Watched.WatchedDate,
			&i.Watched.WatchedInTheater,
			&i.Watched.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedPerMonthLastYear = `-- name: GetWatchedPerMonthLastYear :many
SELECT
    watched_date
FROM
    watched
WHERE
    watched_date >= date('now', 'start of month', '-12 months')
    AND user_id = ?
ORDER BY
    watched_date
`

func (q *Queries) GetWatchedPerMonthLastYear(ctx context.Context, userID *int64) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedPerMonthLastYear, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var watched_date time.Time
		if err := rows.Scan(&watched_date); err != nil {
			return nil, err
		}
		items = append(items, watched_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedPerYear = `-- name: GetWatchedPerYear :many
SELECT
    watched_date
FROM
    watched
WHERE
    user_id = ?
ORDER BY
    watched_date
`

func (q *Queries) GetWatchedPerYear(ctx context.Context, userID *int64) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedPerYear, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var watched_date time.Time
		if err := rows.Scan(&watched_date); err != nil {
			return nil, err
		}
		items = append(items, watched_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedRuntimesLastYear = `-- name: GetWatchedRuntimesLastYear :many
SELECT
    watched.watched_date,
    movie.runtime
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    watched.watched_date >= date('now', 'start of month', '-12 months')
    AND movie.runtime > 0
    AND watched.user_id = ?
ORDER BY
    watched.watched_date
`

type GetWatchedRuntimesLastYearRow struct {
	WatchedDate time.Time
	Runtime     int64
}

func (q *Queries) GetWatchedRuntimesLastYear(ctx context.Context, userID *int64) ([]GetWatchedRuntimesLastYearRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedRuntimesLastYear, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedRuntimesLastYearRow
	for rows.Next() {
		var i GetWatchedRuntimesLastYearRow
		if err := rows.Scan(&i.WatchedDate, &i.Runtime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchlistID = `-- name: GetWatchlistID :one
SELECT
    id
FROM
    list
WHERE
    user_id = ?
    AND is_watchlist = TRUE
`

func (q *Queries) GetWatchlistID(ctx context.Context, userID *int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getWatchlistID, userID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertList = `-- name: InsertList :one
INSERT INTO
    list (
        name,
        creation_date,
        description,
        user_id,
		is_watchlist
    )
VALUES
    (?, ?, ?, ?, ?)
RETURNING
    id
`

type InsertListParams struct {
	Name         string
	CreationDate string
	Description  *string
	UserID       *int64
	IsWatchlist  bool
}

func (q *Queries) InsertList(ctx context.Context, arg InsertListParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertList,
		arg.Name,
		arg.CreationDate,
		arg.Description,
		arg.UserID,
		arg.IsWatchlist,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertWatched = `-- name: InsertWatched :one
INSERT INTO
    watched (movie_id, watched_date, watched_in_theater, user_id, rating)
VALUES
    (?, ?, ?, ?, ?)
RETURNING
    id, movie_id, user_id, watched_date, watched_in_theater, rating
`

type InsertWatchedParams struct {
	MovieID          int64
	WatchedDate      time.Time
	WatchedInTheater bool
	UserID           *int64
	Rating           *float64
}

func (q *Queries) InsertWatched(ctx context.Context, arg InsertWatchedParams) (Watched, error) {
	row := q.db.QueryRowContext(ctx, insertWatched,
		arg.MovieID,
		arg.WatchedDate,
		arg.WatchedInTheater,
		arg.UserID,
		arg.Rating,
	)
	var i Watched
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.UserID,
		&i.WatchedDate,
		&i.WatchedInTheater,
		&i.Rating,
	)
	return i, err
}

const setAdmin = `-- name: SetAdmin :exec
UPDATE
    user
SET
    admin = TRUE
WHERE
    id = ?
`

func (q *Queries) SetAdmin(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setAdmin, id)
	return err
}

const updatePasswordResetRequired = `-- name: UpdatePasswordResetRequired :exec
UPDATE
    user
SET
    password_reset_required = ?
WHERE
    id = ?
`

type UpdatePasswordResetRequiredParams struct {
	PasswordResetRequired bool
	ID                    int64
}

func (q *Queries) UpdatePasswordResetRequired(ctx context.Context, arg UpdatePasswordResetRequiredParams) error {
	_, err := q.db.ExecContext(ctx, updatePasswordResetRequired, arg.PasswordResetRequired, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE
    user
SET
    password_hash = ?
WHERE
    id = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash string
	ID           int64
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const upsertCast = `-- name: UpsertCast :exec
INSERT INTO
    cast (
        movie_id,
        person_id,
        cast_id,
        credit_id,
        character,
        cast_order,
        updated_at
    )
VALUES
    (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP) ON CONFLICT(movie_id, person_id, cast_id) DO
UPDATE
SET
    credit_id = excluded.credit_id,
    character = excluded.character,
    cast_order = excluded.cast_order,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertCastParams struct {
	MovieID   int64
	PersonID  int64
	CastID    int64
	CreditID  string
	Character string
	CastOrder int64
}

func (q *Queries) UpsertCast(ctx context.Context, arg UpsertCastParams) error {
	_, err := q.db.ExecContext(ctx, upsertCast,
		arg.MovieID,
		arg.PersonID,
		arg.CastID,
		arg.CreditID,
		arg.Character,
		arg.CastOrder,
	)
	return err
}

const upsertCrew = `-- name: UpsertCrew :exec
INSERT INTO
    crew (
        movie_id,
        person_id,
        credit_id,
        job,
        department,
        updated_at
    )
VALUES
    (?, ?, ?, ?, ?, CURRENT_TIMESTAMP) ON CONFLICT(movie_id, person_id, credit_id) DO
UPDATE
SET
    job = excluded.job,
    department = excluded.department,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertCrewParams struct {
	MovieID    int64
	PersonID   int64
	CreditID   string
	Job        string
	Department string
}

func (q *Queries) UpsertCrew(ctx context.Context, arg UpsertCrewParams) error {
	_, err := q.db.ExecContext(ctx, upsertCrew,
		arg.MovieID,
		arg.PersonID,
		arg.CreditID,
		arg.Job,
		arg.Department,
	)
	return err
}

const upsertGenre = `-- name: UpsertGenre :exec
INSERT INTO
    genre (id, name, updated_at)
VALUES
    (?, ?, CURRENT_TIMESTAMP) ON CONFLICT(id) DO
UPDATE
SET
    name = excluded.name,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertGenreParams struct {
	ID   int64
	Name string
}

func (q *Queries) UpsertGenre(ctx context.Context, arg UpsertGenreParams) error {
	_, err := q.db.ExecContext(ctx, upsertGenre, arg.ID, arg.Name)
	return err
}

const upsertGenreMovie = `-- name: UpsertGenreMovie :exec
INSERT INTO
    genre_movie (movie_id, genre_id, updated_at)
VALUES
    (?, ?, CURRENT_TIMESTAMP) ON CONFLICT(movie_id, genre_id) DO
UPDATE
SET
    updated_at = CURRENT_TIMESTAMP
`

type UpsertGenreMovieParams struct {
	MovieID int64
	GenreID int64
}

func (q *Queries) UpsertGenreMovie(ctx context.Context, arg UpsertGenreMovieParams) error {
	_, err := q.db.ExecContext(ctx, upsertGenreMovie, arg.MovieID, arg.GenreID)
	return err
}

const upsertMovie = `-- name: UpsertMovie :exec
INSERT INTO
    movie (
        id,
        title,
        original_title,
        original_language,
        overview,
        release_date,
        poster_path,
        backdrop_path,
        popularity,
        vote_count,
        vote_average,
        budget,
        homepage,
        imdb_id,
        revenue,
        runtime,
        STATUS,
        tagline,
        updated_at
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        CURRENT_TIMESTAMP
    ) ON CONFLICT(id) DO
UPDATE
SET
    title = excluded.title,
    original_title = excluded.original_title,
    original_language = excluded.original_language,
    overview = excluded.overview,
    release_date = excluded.release_date,
    poster_path = excluded.poster_path,
    backdrop_path = excluded.backdrop_path,
    popularity = excluded.popularity,
    vote_count = excluded.vote_count,
    vote_average = excluded.vote_average,
    budget = excluded.budget,
    homepage = excluded.homepage,
    imdb_id = excluded.imdb_id,
    revenue = excluded.revenue,
    runtime = excluded.runtime,
    STATUS = excluded.STATUS,
    tagline = excluded.tagline,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertMovieParams struct {
	ID               int64
	Title            string
	OriginalTitle    string
	OriginalLanguage string
	Overview         string
	ReleaseDate      *time.Time
	PosterPath       string
	BackdropPath     string
	Popularity       float64
	VoteCount        int64
	VoteAverage      float64
	Budget           int64
	Homepage         string
	ImdbID           string
	Revenue          int64
	Runtime          int64
	Status           string
	Tagline          string
}

func (q *Queries) UpsertMovie(ctx context.Context, arg UpsertMovieParams) error {
	_, err := q.db.ExecContext(ctx, upsertMovie,
		arg.ID,
		arg.Title,
		arg.OriginalTitle,
		arg.OriginalLanguage,
		arg.Overview,
		arg.ReleaseDate,
		arg.PosterPath,
		arg.BackdropPath,
		arg.Popularity,
		arg.VoteCount,
		arg.VoteAverage,
		arg.Budget,
		arg.Homepage,
		arg.ImdbID,
		arg.Revenue,
		arg.Runtime,
		arg.Status,
		arg.Tagline,
	)
	return err
}

const upsertPerson = `-- name: UpsertPerson :exec
INSERT INTO
    person (
        id,
        name,
        original_name,
        profile_path,
        known_for_department,
        popularity,
        gender,
        adult,
        updated_at
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP) ON CONFLICT(id) DO
UPDATE
SET
    name = excluded.name,
    original_name = excluded.original_name,
    profile_path = excluded.profile_path,
    known_for_department = excluded.known_for_department,
    popularity = excluded.popularity,
    gender = excluded.gender,
    adult = excluded.adult,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertPersonParams struct {
	ID                 int64
	Name               string
	OriginalName       string
	ProfilePath        string
	KnownForDepartment string
	Popularity         float64
	Gender             int64
	Adult              bool
}

func (q *Queries) UpsertPerson(ctx context.Context, arg UpsertPersonParams) error {
	_, err := q.db.ExecContext(ctx, upsertPerson,
		arg.ID,
		arg.Name,
		arg.OriginalName,
		arg.ProfilePath,
		arg.KnownForDepartment,
		arg.Popularity,
		arg.Gender,
		arg.Adult,
	)
	return err
}
