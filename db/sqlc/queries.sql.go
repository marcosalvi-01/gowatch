// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"
	"time"
)

const getAllWatchedForExport = `-- name: GetAllWatchedForExport :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline,
    watched.movie_id, watched.watched_date, watched.watched_in_theater
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
`

type GetAllWatchedForExportRow struct {
	Movie   Movie
	Watched Watched
}

func (q *Queries) GetAllWatchedForExport(ctx context.Context) ([]GetAllWatchedForExportRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllWatchedForExport)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllWatchedForExportRow
	for rows.Next() {
		var i GetAllWatchedForExportRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Watched.MovieID,
			&i.Watched.WatchedDate,
			&i.Watched.WatchedInTheater,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCastByMovieID = `-- name: GetCastByMovieID :many
SELECT
    movie_id, person_id, cast_id, credit_id, character, cast_order
FROM
    cast
WHERE
    movie_id = ?
`

func (q *Queries) GetCastByMovieID(ctx context.Context, movieID int64) ([]Cast, error) {
	rows, err := q.db.QueryContext(ctx, getCastByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cast
	for rows.Next() {
		var i Cast
		if err := rows.Scan(
			&i.MovieID,
			&i.PersonID,
			&i.CastID,
			&i.CreditID,
			&i.Character,
			&i.CastOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCrewByMovieID = `-- name: GetCrewByMovieID :many
SELECT
    movie_id, person_id, credit_id, job, department
FROM
    crew
WHERE
    movie_id = ?
`

func (q *Queries) GetCrewByMovieID(ctx context.Context, movieID int64) ([]Crew, error) {
	rows, err := q.db.QueryContext(ctx, getCrewByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Crew
	for rows.Next() {
		var i Crew
		if err := rows.Scan(
			&i.MovieID,
			&i.PersonID,
			&i.CreditID,
			&i.Job,
			&i.Department,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedMovies = `-- name: GetMostWatchedMovies :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline,
    COUNT(*) AS view_count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
GROUP BY
    movie.id
ORDER BY
    view_count DESC
`

type GetMostWatchedMoviesRow struct {
	Movie     Movie
	ViewCount int64
}

func (q *Queries) GetMostWatchedMovies(ctx context.Context) ([]GetMostWatchedMoviesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostWatchedMoviesRow
	for rows.Next() {
		var i GetMostWatchedMoviesRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.ViewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieByID = `-- name: GetMovieByID :one
SELECT
    id, title, original_title, original_language, overview, release_date, poster_path, backdrop_path, popularity, vote_count, vote_average, budget, homepage, imdb_id, revenue, runtime, status, tagline
FROM
    movie
WHERE
    id = ?
`

func (q *Queries) GetMovieByID(ctx context.Context, id int64) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByID, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.OriginalTitle,
		&i.OriginalLanguage,
		&i.Overview,
		&i.ReleaseDate,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Popularity,
		&i.VoteCount,
		&i.VoteAverage,
		&i.Budget,
		&i.Homepage,
		&i.ImdbID,
		&i.Revenue,
		&i.Runtime,
		&i.Status,
		&i.Tagline,
	)
	return i, err
}

const getMovieByName = `-- name: GetMovieByName :one
SELECT
    id, title, original_title, original_language, overview, release_date, poster_path, backdrop_path, popularity, vote_count, vote_average, budget, homepage, imdb_id, revenue, runtime, status, tagline
FROM
    movie
WHERE
    title = ?
`

func (q *Queries) GetMovieByName(ctx context.Context, title string) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByName, title)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.OriginalTitle,
		&i.OriginalLanguage,
		&i.Overview,
		&i.ReleaseDate,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Popularity,
		&i.VoteCount,
		&i.VoteAverage,
		&i.Budget,
		&i.Homepage,
		&i.ImdbID,
		&i.Revenue,
		&i.Runtime,
		&i.Status,
		&i.Tagline,
	)
	return i, err
}

const getMovieGenre = `-- name: GetMovieGenre :many
SELECT
    id, name, movie_id, genre_id
FROM
    genre
    JOIN genre_movie ON genre.id = genre_movie.genre_id
WHERE
    genre_movie.movie_id = ?
`

type GetMovieGenreRow struct {
	ID      int64
	Name    string
	MovieID int64
	GenreID int64
}

func (q *Queries) GetMovieGenre(ctx context.Context, movieID int64) ([]GetMovieGenreRow, error) {
	rows, err := q.db.QueryContext(ctx, getMovieGenre, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMovieGenreRow
	for rows.Next() {
		var i GetMovieGenreRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MovieID,
			&i.GenreID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerson = `-- name: GetPerson :one
SELECT
    id, name, original_name, profile_path, known_for_department, popularity, gender, adult
FROM
    person
WHERE
    id = ?
`

func (q *Queries) GetPerson(ctx context.Context, id int64) (Person, error) {
	row := q.db.QueryRowContext(ctx, getPerson, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalName,
		&i.ProfilePath,
		&i.KnownForDepartment,
		&i.Popularity,
		&i.Gender,
		&i.Adult,
	)
	return i, err
}

const getWatchedJoinMovie = `-- name: GetWatchedJoinMovie :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline,
    watched.movie_id, watched.watched_date, watched.watched_in_theater
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
`

type GetWatchedJoinMovieRow struct {
	Movie   Movie
	Watched Watched
}

func (q *Queries) GetWatchedJoinMovie(ctx context.Context) ([]GetWatchedJoinMovieRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedJoinMovie)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedJoinMovieRow
	for rows.Next() {
		var i GetWatchedJoinMovieRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Watched.MovieID,
			&i.Watched.WatchedDate,
			&i.Watched.WatchedInTheater,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedJoinMovieByID = `-- name: GetWatchedJoinMovieByID :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline,
    watched.movie_id, watched.watched_date, watched.watched_in_theater
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    watched.movie_id = ?
ORDER BY
    watched.watched_date DESC
`

type GetWatchedJoinMovieByIDRow struct {
	Movie   Movie
	Watched Watched
}

func (q *Queries) GetWatchedJoinMovieByID(ctx context.Context, movieID int64) ([]GetWatchedJoinMovieByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedJoinMovieByID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedJoinMovieByIDRow
	for rows.Next() {
		var i GetWatchedJoinMovieByIDRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Watched.MovieID,
			&i.Watched.WatchedDate,
			&i.Watched.WatchedInTheater,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedMovieDetails = `-- name: GetWatchedMovieDetails :one
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline,
    COUNT(*) AS view_count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    movie.id = ?
GROUP BY
    movie.id
`

type GetWatchedMovieDetailsRow struct {
	Movie     Movie
	ViewCount int64
}

func (q *Queries) GetWatchedMovieDetails(ctx context.Context, id int64) (GetWatchedMovieDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getWatchedMovieDetails, id)
	var i GetWatchedMovieDetailsRow
	err := row.Scan(
		&i.Movie.ID,
		&i.Movie.Title,
		&i.Movie.OriginalTitle,
		&i.Movie.OriginalLanguage,
		&i.Movie.Overview,
		&i.Movie.ReleaseDate,
		&i.Movie.PosterPath,
		&i.Movie.BackdropPath,
		&i.Movie.Popularity,
		&i.Movie.VoteCount,
		&i.Movie.VoteAverage,
		&i.Movie.Budget,
		&i.Movie.Homepage,
		&i.Movie.ImdbID,
		&i.Movie.Revenue,
		&i.Movie.Runtime,
		&i.Movie.Status,
		&i.Movie.Tagline,
		&i.ViewCount,
	)
	return i, err
}

const insertCast = `-- name: InsertCast :exec
INSERT
    OR IGNORE INTO cast (
        movie_id,
        person_id,
        cast_id,
        credit_id,
        character,
        cast_order
    )
VALUES
    (?, ?, ?, ?, ?, ?)
`

type InsertCastParams struct {
	MovieID   int64
	PersonID  int64
	CastID    int64
	CreditID  string
	Character string
	CastOrder int64
}

func (q *Queries) InsertCast(ctx context.Context, arg InsertCastParams) error {
	_, err := q.db.ExecContext(ctx, insertCast,
		arg.MovieID,
		arg.PersonID,
		arg.CastID,
		arg.CreditID,
		arg.Character,
		arg.CastOrder,
	)
	return err
}

const insertCrew = `-- name: InsertCrew :exec
INSERT
    OR IGNORE INTO crew (
        movie_id,
        person_id,
        credit_id,
        job,
        department
    )
VALUES
    (?, ?, ?, ?, ?)
`

type InsertCrewParams struct {
	MovieID    int64
	PersonID   int64
	CreditID   string
	Job        string
	Department string
}

func (q *Queries) InsertCrew(ctx context.Context, arg InsertCrewParams) error {
	_, err := q.db.ExecContext(ctx, insertCrew,
		arg.MovieID,
		arg.PersonID,
		arg.CreditID,
		arg.Job,
		arg.Department,
	)
	return err
}

const insertGenre = `-- name: InsertGenre :exec
INSERT
    OR IGNORE INTO genre (id, name)
VALUES
    (?, ?)
`

type InsertGenreParams struct {
	ID   int64
	Name string
}

func (q *Queries) InsertGenre(ctx context.Context, arg InsertGenreParams) error {
	_, err := q.db.ExecContext(ctx, insertGenre, arg.ID, arg.Name)
	return err
}

const insertGenreMovie = `-- name: InsertGenreMovie :exec
INSERT
    OR IGNORE INTO genre_movie (movie_id, genre_id)
VALUES
    (?, ?)
`

type InsertGenreMovieParams struct {
	MovieID int64
	GenreID int64
}

func (q *Queries) InsertGenreMovie(ctx context.Context, arg InsertGenreMovieParams) error {
	_, err := q.db.ExecContext(ctx, insertGenreMovie, arg.MovieID, arg.GenreID)
	return err
}

const insertMovie = `-- name: InsertMovie :exec
INSERT
    OR IGNORE INTO movie (
        id,
        title,
        original_title,
        original_language,
        overview,
        release_date,
        poster_path,
        backdrop_path,
        popularity,
        vote_count,
        vote_average,
        budget,
        homepage,
        imdb_id,
        revenue,
        runtime,
        STATUS,
        tagline
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
    )
`

type InsertMovieParams struct {
	ID               int64
	Title            string
	OriginalTitle    string
	OriginalLanguage string
	Overview         string
	ReleaseDate      time.Time
	PosterPath       string
	BackdropPath     string
	Popularity       float64
	VoteCount        int64
	VoteAverage      float64
	Budget           int64
	Homepage         string
	ImdbID           string
	Revenue          int64
	Runtime          int64
	Status           string
	Tagline          string
}

func (q *Queries) InsertMovie(ctx context.Context, arg InsertMovieParams) error {
	_, err := q.db.ExecContext(ctx, insertMovie,
		arg.ID,
		arg.Title,
		arg.OriginalTitle,
		arg.OriginalLanguage,
		arg.Overview,
		arg.ReleaseDate,
		arg.PosterPath,
		arg.BackdropPath,
		arg.Popularity,
		arg.VoteCount,
		arg.VoteAverage,
		arg.Budget,
		arg.Homepage,
		arg.ImdbID,
		arg.Revenue,
		arg.Runtime,
		arg.Status,
		arg.Tagline,
	)
	return err
}

const insertPerson = `-- name: InsertPerson :exec
INSERT
    OR IGNORE INTO person (
        id,
        name,
        original_name,
        profile_path,
        known_for_department,
        popularity,
        gender,
        adult
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertPersonParams struct {
	ID                 int64
	Name               string
	OriginalName       string
	ProfilePath        string
	KnownForDepartment string
	Popularity         float64
	Gender             int64
	Adult              bool
}

func (q *Queries) InsertPerson(ctx context.Context, arg InsertPersonParams) error {
	_, err := q.db.ExecContext(ctx, insertPerson,
		arg.ID,
		arg.Name,
		arg.OriginalName,
		arg.ProfilePath,
		arg.KnownForDepartment,
		arg.Popularity,
		arg.Gender,
		arg.Adult,
	)
	return err
}

const insertWatched = `-- name: InsertWatched :one
INSERT INTO
    watched (movie_id, watched_date, watched_in_theater)
VALUES
    (?, ?, ?)
RETURNING
    movie_id, watched_date, watched_in_theater
`

type InsertWatchedParams struct {
	MovieID          int64
	WatchedDate      time.Time
	WatchedInTheater bool
}

func (q *Queries) InsertWatched(ctx context.Context, arg InsertWatchedParams) (Watched, error) {
	row := q.db.QueryRowContext(ctx, insertWatched, arg.MovieID, arg.WatchedDate, arg.WatchedInTheater)
	var i Watched
	err := row.Scan(&i.MovieID, &i.WatchedDate, &i.WatchedInTheater)
	return i, err
}
