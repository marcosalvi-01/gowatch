// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"time"
)

const addMovieToList = `-- name: AddMovieToList :exec
INSERT INTO
    list_movie (
        movie_id,
        list_id,
        date_added,
        position,
        note
    )
VALUES
    (?, ?, ?, ?, ?)
`

type AddMovieToListParams struct {
	MovieID   int64
	ListID    int64
	DateAdded string
	Position  *int64
	Note      *string
}

func (q *Queries) AddMovieToList(ctx context.Context, arg AddMovieToListParams) error {
	_, err := q.db.ExecContext(ctx, addMovieToList,
		arg.MovieID,
		arg.ListID,
		arg.DateAdded,
		arg.Position,
		arg.Note,
	)
	return err
}

const deleteListByID = `-- name: DeleteListByID :exec
DELETE FROM
    list
WHERE
    id = ?
`

func (q *Queries) DeleteListByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteListByID, id)
	return err
}

const deleteMovieFromList = `-- name: DeleteMovieFromList :exec
DELETE FROM
    list_movie
WHERE
    list_id = ?
    AND movie_id = ?
`

type DeleteMovieFromListParams struct {
	ListID  int64
	MovieID int64
}

func (q *Queries) DeleteMovieFromList(ctx context.Context, arg DeleteMovieFromListParams) error {
	_, err := q.db.ExecContext(ctx, deleteMovieFromList, arg.ListID, arg.MovieID)
	return err
}

const getAllLists = `-- name: GetAllLists :many
SELECT
    id, name, creation_date, description
FROM
    list
`

func (q *Queries) GetAllLists(ctx context.Context) ([]List, error) {
	rows, err := q.db.QueryContext(ctx, getAllLists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []List
	for rows.Next() {
		var i List
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreationDate,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCastByMovieID = `-- name: GetCastByMovieID :many
SELECT
    movie_id, person_id, cast_id, credit_id, character, cast_order, updated_at
FROM
    cast
WHERE
    movie_id = ?
`

func (q *Queries) GetCastByMovieID(ctx context.Context, movieID int64) ([]Cast, error) {
	rows, err := q.db.QueryContext(ctx, getCastByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cast
	for rows.Next() {
		var i Cast
		if err := rows.Scan(
			&i.MovieID,
			&i.PersonID,
			&i.CastID,
			&i.CreditID,
			&i.Character,
			&i.CastOrder,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCrewByMovieID = `-- name: GetCrewByMovieID :many
SELECT
    movie_id, person_id, credit_id, job, department, updated_at
FROM
    crew
WHERE
    movie_id = ?
`

func (q *Queries) GetCrewByMovieID(ctx context.Context, movieID int64) ([]Crew, error) {
	rows, err := q.db.QueryContext(ctx, getCrewByMovieID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Crew
	for rows.Next() {
		var i Crew
		if err := rows.Scan(
			&i.MovieID,
			&i.PersonID,
			&i.CreditID,
			&i.Job,
			&i.Department,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListByID = `-- name: GetListByID :one
SELECT
    id, name, creation_date, description
FROM
    list
WHERE
    id = ?
`

func (q *Queries) GetListByID(ctx context.Context, id int64) (List, error) {
	row := q.db.QueryRowContext(ctx, getListByID, id)
	var i List
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreationDate,
		&i.Description,
	)
	return i, err
}

const getListJoinMovieByID = `-- name: GetListJoinMovieByID :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline, movie.updated_at,
    list_movie.movie_id, list_movie.list_id, list_movie.date_added, list_movie.position, list_movie.note,
    list.id, list.name, list.creation_date, list.description
FROM
    list
    JOIN list_movie ON list_movie.list_id = list.id
    JOIN movie ON movie.id = list_movie.movie_id
WHERE
    list.id = ?
`

type GetListJoinMovieByIDRow struct {
	Movie     Movie
	ListMovie ListMovie
	List      List
}

func (q *Queries) GetListJoinMovieByID(ctx context.Context, id int64) ([]GetListJoinMovieByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getListJoinMovieByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListJoinMovieByIDRow
	for rows.Next() {
		var i GetListJoinMovieByIDRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Movie.UpdatedAt,
			&i.ListMovie.MovieID,
			&i.ListMovie.ListID,
			&i.ListMovie.DateAdded,
			&i.ListMovie.Position,
			&i.ListMovie.Note,
			&i.List.ID,
			&i.List.Name,
			&i.List.CreationDate,
			&i.List.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedDay = `-- name: GetMostWatchedDay :many
SELECT
    watched_date
FROM
    watched
`

func (q *Queries) GetMostWatchedDay(ctx context.Context) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedDay)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var watched_date time.Time
		if err := rows.Scan(&watched_date); err != nil {
			return nil, err
		}
		items = append(items, watched_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedFemaleActors = `-- name: GetMostWatchedFemaleActors :many
SELECT
    person.name,
    person.id,
    person.profile_path,
    person.gender,
    COUNT(*) AS watch_count
FROM
    watched
    JOIN "cast" ON watched.movie_id = "cast".movie_id
    JOIN person ON "cast".person_id = person.id
WHERE
    person.gender = 1
GROUP BY
    person.id,
    person.name,
    person.profile_path,
    person.gender
ORDER BY
    watch_count DESC
LIMIT
    ?
`

type GetMostWatchedFemaleActorsRow struct {
	Name        string
	ID          int64
	ProfilePath string
	Gender      int64
	WatchCount  int64
}

func (q *Queries) GetMostWatchedFemaleActors(ctx context.Context, limit int64) ([]GetMostWatchedFemaleActorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedFemaleActors, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostWatchedFemaleActorsRow
	for rows.Next() {
		var i GetMostWatchedFemaleActorsRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.ProfilePath,
			&i.Gender,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedMaleActors = `-- name: GetMostWatchedMaleActors :many
SELECT
    person.name,
    person.id,
    person.profile_path,
    person.gender,
    COUNT(*) AS watch_count
FROM
    watched
    JOIN "cast" ON watched.movie_id = "cast".movie_id
    JOIN person ON "cast".person_id = person.id
WHERE
    person.gender = 2
GROUP BY
    person.id,
    person.name,
    person.profile_path,
    person.gender
ORDER BY
    watch_count DESC
LIMIT
    ?
`

type GetMostWatchedMaleActorsRow struct {
	Name        string
	ID          int64
	ProfilePath string
	Gender      int64
	WatchCount  int64
}

func (q *Queries) GetMostWatchedMaleActors(ctx context.Context, limit int64) ([]GetMostWatchedMaleActorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedMaleActors, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostWatchedMaleActorsRow
	for rows.Next() {
		var i GetMostWatchedMaleActorsRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.ProfilePath,
			&i.Gender,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedMovies = `-- name: GetMostWatchedMovies :many
SELECT
    movie.title,
    movie.id,
    movie.poster_path,
    COUNT(*) AS watch_count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
GROUP BY
    movie.id,
    movie.title,
    movie.poster_path
ORDER BY
    watch_count DESC
LIMIT
    ?
`

type GetMostWatchedMoviesRow struct {
	Title      string
	ID         int64
	PosterPath string
	WatchCount int64
}

func (q *Queries) GetMostWatchedMovies(ctx context.Context, limit int64) ([]GetMostWatchedMoviesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedMovies, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostWatchedMoviesRow
	for rows.Next() {
		var i GetMostWatchedMoviesRow
		if err := rows.Scan(
			&i.Title,
			&i.ID,
			&i.PosterPath,
			&i.WatchCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieByID = `-- name: GetMovieByID :one
SELECT
    id, title, original_title, original_language, overview, release_date, poster_path, backdrop_path, popularity, vote_count, vote_average, budget, homepage, imdb_id, revenue, runtime, status, tagline, updated_at
FROM
    movie
WHERE
    id = ?
`

func (q *Queries) GetMovieByID(ctx context.Context, id int64) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByID, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.OriginalTitle,
		&i.OriginalLanguage,
		&i.Overview,
		&i.ReleaseDate,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Popularity,
		&i.VoteCount,
		&i.VoteAverage,
		&i.Budget,
		&i.Homepage,
		&i.ImdbID,
		&i.Revenue,
		&i.Runtime,
		&i.Status,
		&i.Tagline,
		&i.UpdatedAt,
	)
	return i, err
}

const getMovieGenre = `-- name: GetMovieGenre :many
SELECT
    id, name, genre.updated_at, movie_id, genre_id, genre_movie.updated_at
FROM
    genre
    JOIN genre_movie ON genre.id = genre_movie.genre_id
WHERE
    genre_movie.movie_id = ?
`

type GetMovieGenreRow struct {
	ID          int64
	Name        string
	UpdatedAt   *time.Time
	MovieID     int64
	GenreID     int64
	UpdatedAt_2 *time.Time
}

func (q *Queries) GetMovieGenre(ctx context.Context, movieID int64) ([]GetMovieGenreRow, error) {
	rows, err := q.db.QueryContext(ctx, getMovieGenre, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMovieGenreRow
	for rows.Next() {
		var i GetMovieGenreRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UpdatedAt,
			&i.MovieID,
			&i.GenreID,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerson = `-- name: GetPerson :one
SELECT
    id, name, original_name, profile_path, known_for_department, popularity, gender, adult, updated_at
FROM
    person
WHERE
    id = ?
`

func (q *Queries) GetPerson(ctx context.Context, id int64) (Person, error) {
	row := q.db.QueryRowContext(ctx, getPerson, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalName,
		&i.ProfilePath,
		&i.KnownForDepartment,
		&i.Popularity,
		&i.Gender,
		&i.Adult,
		&i.UpdatedAt,
	)
	return i, err
}

const getTheaterVsHomeCount = `-- name: GetTheaterVsHomeCount :many
SELECT
    watched_in_theater,
    COUNT(*) AS count
FROM
    watched
GROUP BY
    watched_in_theater
`

type GetTheaterVsHomeCountRow struct {
	WatchedInTheater bool
	Count            int64
}

func (q *Queries) GetTheaterVsHomeCount(ctx context.Context) ([]GetTheaterVsHomeCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getTheaterVsHomeCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTheaterVsHomeCountRow
	for rows.Next() {
		var i GetTheaterVsHomeCountRow
		if err := rows.Scan(&i.WatchedInTheater, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedByGenre = `-- name: GetWatchedByGenre :many
SELECT
    genre.name,
    COUNT(*) AS count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
    JOIN genre_movie ON movie.id = genre_movie.movie_id
    JOIN genre ON genre_movie.genre_id = genre.id
GROUP BY
    genre.id,
    genre.name
ORDER BY
    count DESC
`

type GetWatchedByGenreRow struct {
	Name  string
	Count int64
}

func (q *Queries) GetWatchedByGenre(ctx context.Context) ([]GetWatchedByGenreRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedByGenre)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedByGenreRow
	for rows.Next() {
		var i GetWatchedByGenreRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedCount = `-- name: GetWatchedCount :one
SELECT
    COUNT(*) AS count
FROM
    watched
`

func (q *Queries) GetWatchedCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getWatchedCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWatchedDateRange = `-- name: GetWatchedDateRange :one
SELECT
    MIN(watched_date) AS min_date,
    MAX(watched_date) AS max_date
FROM
    watched
WHERE
    watched_date IS NOT NULL
`

type GetWatchedDateRangeRow struct {
	MinDate interface{}
	MaxDate interface{}
}

func (q *Queries) GetWatchedDateRange(ctx context.Context) (GetWatchedDateRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getWatchedDateRange)
	var i GetWatchedDateRangeRow
	err := row.Scan(&i.MinDate, &i.MaxDate)
	return i, err
}

const getWatchedDates = `-- name: GetWatchedDates :many
SELECT
    watched_date
FROM
    watched
ORDER BY
    watched_date
`

func (q *Queries) GetWatchedDates(ctx context.Context) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedDates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var watched_date time.Time
		if err := rows.Scan(&watched_date); err != nil {
			return nil, err
		}
		items = append(items, watched_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedJoinMovie = `-- name: GetWatchedJoinMovie :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline, movie.updated_at,
    watched.movie_id, watched.watched_date, watched.watched_in_theater
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
`

type GetWatchedJoinMovieRow struct {
	Movie   Movie
	Watched Watched
}

func (q *Queries) GetWatchedJoinMovie(ctx context.Context) ([]GetWatchedJoinMovieRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedJoinMovie)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedJoinMovieRow
	for rows.Next() {
		var i GetWatchedJoinMovieRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Movie.UpdatedAt,
			&i.Watched.MovieID,
			&i.Watched.WatchedDate,
			&i.Watched.WatchedInTheater,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedJoinMovieByID = `-- name: GetWatchedJoinMovieByID :many
SELECT
    movie.id, movie.title, movie.original_title, movie.original_language, movie.overview, movie.release_date, movie.poster_path, movie.backdrop_path, movie.popularity, movie.vote_count, movie.vote_average, movie.budget, movie.homepage, movie.imdb_id, movie.revenue, movie.runtime, movie.status, movie.tagline, movie.updated_at,
    watched.movie_id, watched.watched_date, watched.watched_in_theater
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    watched.movie_id = ?
ORDER BY
    watched.watched_date DESC
`

type GetWatchedJoinMovieByIDRow struct {
	Movie   Movie
	Watched Watched
}

func (q *Queries) GetWatchedJoinMovieByID(ctx context.Context, movieID int64) ([]GetWatchedJoinMovieByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedJoinMovieByID, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedJoinMovieByIDRow
	for rows.Next() {
		var i GetWatchedJoinMovieByIDRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.ReleaseDate,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Popularity,
			&i.Movie.VoteCount,
			&i.Movie.VoteAverage,
			&i.Movie.Budget,
			&i.Movie.Homepage,
			&i.Movie.ImdbID,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Movie.UpdatedAt,
			&i.Watched.MovieID,
			&i.Watched.WatchedDate,
			&i.Watched.WatchedInTheater,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedPerMonthLastYear = `-- name: GetWatchedPerMonthLastYear :many
SELECT
    watched_date
FROM
    watched
WHERE
    watched_date >= date('now', 'start of month', '-12 months')
    AND watched_date < date('now', 'start of month')
ORDER BY
    watched_date
`

func (q *Queries) GetWatchedPerMonthLastYear(ctx context.Context) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedPerMonthLastYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var watched_date time.Time
		if err := rows.Scan(&watched_date); err != nil {
			return nil, err
		}
		items = append(items, watched_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedPerYear = `-- name: GetWatchedPerYear :many
SELECT
    watched_date
FROM
    watched
ORDER BY
    watched_date
`

func (q *Queries) GetWatchedPerYear(ctx context.Context) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedPerYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var watched_date time.Time
		if err := rows.Scan(&watched_date); err != nil {
			return nil, err
		}
		items = append(items, watched_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertList = `-- name: InsertList :exec
INSERT INTO
    list (
        name,
        creation_date,
        description
    )
VALUES
    (?, ?, ?)
`

type InsertListParams struct {
	Name         string
	CreationDate string
	Description  *string
}

func (q *Queries) InsertList(ctx context.Context, arg InsertListParams) error {
	_, err := q.db.ExecContext(ctx, insertList, arg.Name, arg.CreationDate, arg.Description)
	return err
}

const insertWatched = `-- name: InsertWatched :one
INSERT INTO
    watched (movie_id, watched_date, watched_in_theater)
VALUES
    (?, ?, ?)
RETURNING
    movie_id, watched_date, watched_in_theater
`

type InsertWatchedParams struct {
	MovieID          int64
	WatchedDate      time.Time
	WatchedInTheater bool
}

func (q *Queries) InsertWatched(ctx context.Context, arg InsertWatchedParams) (Watched, error) {
	row := q.db.QueryRowContext(ctx, insertWatched, arg.MovieID, arg.WatchedDate, arg.WatchedInTheater)
	var i Watched
	err := row.Scan(&i.MovieID, &i.WatchedDate, &i.WatchedInTheater)
	return i, err
}

const upsertCast = `-- name: UpsertCast :exec
INSERT INTO
    cast (
        movie_id,
        person_id,
        cast_id,
        credit_id,
        character,
        cast_order,
        updated_at
    )
VALUES
    (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP) ON CONFLICT(movie_id, person_id, cast_id) DO
UPDATE
SET
    credit_id = excluded.credit_id,
    character = excluded.character,
    cast_order = excluded.cast_order,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertCastParams struct {
	MovieID   int64
	PersonID  int64
	CastID    int64
	CreditID  string
	Character string
	CastOrder int64
}

func (q *Queries) UpsertCast(ctx context.Context, arg UpsertCastParams) error {
	_, err := q.db.ExecContext(ctx, upsertCast,
		arg.MovieID,
		arg.PersonID,
		arg.CastID,
		arg.CreditID,
		arg.Character,
		arg.CastOrder,
	)
	return err
}

const upsertCrew = `-- name: UpsertCrew :exec
INSERT INTO
    crew (
        movie_id,
        person_id,
        credit_id,
        job,
        department,
        updated_at
    )
VALUES
    (?, ?, ?, ?, ?, CURRENT_TIMESTAMP) ON CONFLICT(movie_id, person_id, credit_id) DO
UPDATE
SET
    job = excluded.job,
    department = excluded.department,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertCrewParams struct {
	MovieID    int64
	PersonID   int64
	CreditID   string
	Job        string
	Department string
}

func (q *Queries) UpsertCrew(ctx context.Context, arg UpsertCrewParams) error {
	_, err := q.db.ExecContext(ctx, upsertCrew,
		arg.MovieID,
		arg.PersonID,
		arg.CreditID,
		arg.Job,
		arg.Department,
	)
	return err
}

const upsertGenre = `-- name: UpsertGenre :exec
INSERT INTO
    genre (id, name, updated_at)
VALUES
    (?, ?, CURRENT_TIMESTAMP) ON CONFLICT(id) DO
UPDATE
SET
    name = excluded.name,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertGenreParams struct {
	ID   int64
	Name string
}

func (q *Queries) UpsertGenre(ctx context.Context, arg UpsertGenreParams) error {
	_, err := q.db.ExecContext(ctx, upsertGenre, arg.ID, arg.Name)
	return err
}

const upsertGenreMovie = `-- name: UpsertGenreMovie :exec
INSERT INTO
    genre_movie (movie_id, genre_id, updated_at)
VALUES
    (?, ?, CURRENT_TIMESTAMP) ON CONFLICT(movie_id, genre_id) DO
UPDATE
SET
    updated_at = CURRENT_TIMESTAMP
`

type UpsertGenreMovieParams struct {
	MovieID int64
	GenreID int64
}

func (q *Queries) UpsertGenreMovie(ctx context.Context, arg UpsertGenreMovieParams) error {
	_, err := q.db.ExecContext(ctx, upsertGenreMovie, arg.MovieID, arg.GenreID)
	return err
}

const upsertMovie = `-- name: UpsertMovie :exec
INSERT INTO
    movie (
        id,
        title,
        original_title,
        original_language,
        overview,
        release_date,
        poster_path,
        backdrop_path,
        popularity,
        vote_count,
        vote_average,
        budget,
        homepage,
        imdb_id,
        revenue,
        runtime,
        STATUS,
        tagline,
        updated_at
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        CURRENT_TIMESTAMP
    ) ON CONFLICT(id) DO
UPDATE
SET
    title = excluded.title,
    original_title = excluded.original_title,
    original_language = excluded.original_language,
    overview = excluded.overview,
    release_date = excluded.release_date,
    poster_path = excluded.poster_path,
    backdrop_path = excluded.backdrop_path,
    popularity = excluded.popularity,
    vote_count = excluded.vote_count,
    vote_average = excluded.vote_average,
    budget = excluded.budget,
    homepage = excluded.homepage,
    imdb_id = excluded.imdb_id,
    revenue = excluded.revenue,
    runtime = excluded.runtime,
    STATUS = excluded.STATUS,
    tagline = excluded.tagline,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertMovieParams struct {
	ID               int64
	Title            string
	OriginalTitle    string
	OriginalLanguage string
	Overview         string
	ReleaseDate      *time.Time
	PosterPath       string
	BackdropPath     string
	Popularity       float64
	VoteCount        int64
	VoteAverage      float64
	Budget           int64
	Homepage         string
	ImdbID           string
	Revenue          int64
	Runtime          int64
	Status           string
	Tagline          string
}

func (q *Queries) UpsertMovie(ctx context.Context, arg UpsertMovieParams) error {
	_, err := q.db.ExecContext(ctx, upsertMovie,
		arg.ID,
		arg.Title,
		arg.OriginalTitle,
		arg.OriginalLanguage,
		arg.Overview,
		arg.ReleaseDate,
		arg.PosterPath,
		arg.BackdropPath,
		arg.Popularity,
		arg.VoteCount,
		arg.VoteAverage,
		arg.Budget,
		arg.Homepage,
		arg.ImdbID,
		arg.Revenue,
		arg.Runtime,
		arg.Status,
		arg.Tagline,
	)
	return err
}

const upsertPerson = `-- name: UpsertPerson :exec
INSERT INTO
    person (
        id,
        name,
        original_name,
        profile_path,
        known_for_department,
        popularity,
        gender,
        adult,
        updated_at
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP) ON CONFLICT(id) DO
UPDATE
SET
    name = excluded.name,
    original_name = excluded.original_name,
    profile_path = excluded.profile_path,
    known_for_department = excluded.known_for_department,
    popularity = excluded.popularity,
    gender = excluded.gender,
    adult = excluded.adult,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertPersonParams struct {
	ID                 int64
	Name               string
	OriginalName       string
	ProfilePath        string
	KnownForDepartment string
	Popularity         float64
	Gender             int64
	Adult              bool
}

func (q *Queries) UpsertPerson(ctx context.Context, arg UpsertPersonParams) error {
	_, err := q.db.ExecContext(ctx, upsertPerson,
		arg.ID,
		arg.Name,
		arg.OriginalName,
		arg.ProfilePath,
		arg.KnownForDepartment,
		arg.Popularity,
		arg.Gender,
		arg.Adult,
	)
	return err
}
