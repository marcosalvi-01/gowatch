// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"
	"time"
)

const getAllWatched = `-- name: GetAllWatched :many
SELECT
    movie_id, watched_date
FROM
    watched
`

func (q *Queries) GetAllWatched(ctx context.Context) ([]Watched, error) {
	rows, err := q.db.QueryContext(ctx, getAllWatched)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Watched
	for rows.Next() {
		var i Watched
		if err := rows.Scan(&i.MovieID, &i.WatchedDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedMovies = `-- name: GetMostWatchedMovies :many
SELECT
    movie.id, movie.imdb_id, movie.title, movie.original_title, movie.release_date, movie.original_language, movie.overview, movie.poster_path, movie.backdrop_path, movie.budget, movie.revenue, movie.runtime, movie.vote_average, movie.vote_count, movie.popularity, movie.homepage, movie.status, movie.tagline,
    COUNT(*) AS view_count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
GROUP BY
    movie.id
ORDER BY
    view_count DESC
`

type GetMostWatchedMoviesRow struct {
	Movie     Movie
	ViewCount int64
}

func (q *Queries) GetMostWatchedMovies(ctx context.Context) ([]GetMostWatchedMoviesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostWatchedMoviesRow
	for rows.Next() {
		var i GetMostWatchedMoviesRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.ImdbID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.ReleaseDate,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Budget,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.VoteAverage,
			&i.Movie.VoteCount,
			&i.Movie.Popularity,
			&i.Movie.Homepage,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.ViewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieByID = `-- name: GetMovieByID :one
SELECT
    id, imdb_id, title, original_title, release_date, original_language, overview, poster_path, backdrop_path, budget, revenue, runtime, vote_average, vote_count, popularity, homepage, status, tagline
FROM
    movie
WHERE
    id = ?
`

func (q *Queries) GetMovieByID(ctx context.Context, id int64) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByID, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.ReleaseDate,
		&i.OriginalLanguage,
		&i.Overview,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Budget,
		&i.Revenue,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.Homepage,
		&i.Status,
		&i.Tagline,
	)
	return i, err
}

const getMovieByName = `-- name: GetMovieByName :one
SELECT
    id, imdb_id, title, original_title, release_date, original_language, overview, poster_path, backdrop_path, budget, revenue, runtime, vote_average, vote_count, popularity, homepage, status, tagline
FROM
    movie
WHERE
    title = ?
`

func (q *Queries) GetMovieByName(ctx context.Context, title string) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieByName, title)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.ReleaseDate,
		&i.OriginalLanguage,
		&i.Overview,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Budget,
		&i.Revenue,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.Homepage,
		&i.Status,
		&i.Tagline,
	)
	return i, err
}

const getWatchedJoinMovie = `-- name: GetWatchedJoinMovie :many
SELECT
    movie.id, movie.imdb_id, movie.title, movie.original_title, movie.release_date, movie.original_language, movie.overview, movie.poster_path, movie.backdrop_path, movie.budget, movie.revenue, movie.runtime, movie.vote_average, movie.vote_count, movie.popularity, movie.homepage, movie.status, movie.tagline,
    watched.movie_id, watched.watched_date
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
`

type GetWatchedJoinMovieRow struct {
	Movie   Movie
	Watched Watched
}

func (q *Queries) GetWatchedJoinMovie(ctx context.Context) ([]GetWatchedJoinMovieRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedJoinMovie)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedJoinMovieRow
	for rows.Next() {
		var i GetWatchedJoinMovieRow
		if err := rows.Scan(
			&i.Movie.ID,
			&i.Movie.ImdbID,
			&i.Movie.Title,
			&i.Movie.OriginalTitle,
			&i.Movie.ReleaseDate,
			&i.Movie.OriginalLanguage,
			&i.Movie.Overview,
			&i.Movie.PosterPath,
			&i.Movie.BackdropPath,
			&i.Movie.Budget,
			&i.Movie.Revenue,
			&i.Movie.Runtime,
			&i.Movie.VoteAverage,
			&i.Movie.VoteCount,
			&i.Movie.Popularity,
			&i.Movie.Homepage,
			&i.Movie.Status,
			&i.Movie.Tagline,
			&i.Watched.MovieID,
			&i.Watched.WatchedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedMovieDetails = `-- name: GetWatchedMovieDetails :one
SELECT
    movie.id, movie.imdb_id, movie.title, movie.original_title, movie.release_date, movie.original_language, movie.overview, movie.poster_path, movie.backdrop_path, movie.budget, movie.revenue, movie.runtime, movie.vote_average, movie.vote_count, movie.popularity, movie.homepage, movie.status, movie.tagline,
    COUNT(*) AS view_count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
WHERE
    movie.id = ?1
GROUP BY
    movie.id
`

type GetWatchedMovieDetailsRow struct {
	Movie     Movie
	ViewCount int64
}

func (q *Queries) GetWatchedMovieDetails(ctx context.Context, movieID int64) (GetWatchedMovieDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getWatchedMovieDetails, movieID)
	var i GetWatchedMovieDetailsRow
	err := row.Scan(
		&i.Movie.ID,
		&i.Movie.ImdbID,
		&i.Movie.Title,
		&i.Movie.OriginalTitle,
		&i.Movie.ReleaseDate,
		&i.Movie.OriginalLanguage,
		&i.Movie.Overview,
		&i.Movie.PosterPath,
		&i.Movie.BackdropPath,
		&i.Movie.Budget,
		&i.Movie.Revenue,
		&i.Movie.Runtime,
		&i.Movie.VoteAverage,
		&i.Movie.VoteCount,
		&i.Movie.Popularity,
		&i.Movie.Homepage,
		&i.Movie.Status,
		&i.Movie.Tagline,
		&i.ViewCount,
	)
	return i, err
}

const insertMovie = `-- name: InsertMovie :one
INSERT INTO
    movie (
        id,
        imdb_id,
        title,
        original_title,
        release_date,
        original_language,
        overview,
        poster_path,
        backdrop_path,
        budget,
        revenue,
        runtime,
        vote_average,
        vote_count,
        popularity,
        homepage,
        STATUS,
        tagline
    )
VALUES
    (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
    )
RETURNING
    id, imdb_id, title, original_title, release_date, original_language, overview, poster_path, backdrop_path, budget, revenue, runtime, vote_average, vote_count, popularity, homepage, status, tagline
`

type InsertMovieParams struct {
	ID               int64
	ImdbID           string
	Title            string
	OriginalTitle    string
	ReleaseDate      time.Time
	OriginalLanguage string
	Overview         string
	PosterPath       string
	BackdropPath     string
	Budget           int64
	Revenue          int64
	Runtime          int64
	VoteAverage      float64
	VoteCount        int64
	Popularity       float64
	Homepage         string
	Status           string
	Tagline          string
}

func (q *Queries) InsertMovie(ctx context.Context, arg InsertMovieParams) (Movie, error) {
	row := q.db.QueryRowContext(ctx, insertMovie,
		arg.ID,
		arg.ImdbID,
		arg.Title,
		arg.OriginalTitle,
		arg.ReleaseDate,
		arg.OriginalLanguage,
		arg.Overview,
		arg.PosterPath,
		arg.BackdropPath,
		arg.Budget,
		arg.Revenue,
		arg.Runtime,
		arg.VoteAverage,
		arg.VoteCount,
		arg.Popularity,
		arg.Homepage,
		arg.Status,
		arg.Tagline,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.ImdbID,
		&i.Title,
		&i.OriginalTitle,
		&i.ReleaseDate,
		&i.OriginalLanguage,
		&i.Overview,
		&i.PosterPath,
		&i.BackdropPath,
		&i.Budget,
		&i.Revenue,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Popularity,
		&i.Homepage,
		&i.Status,
		&i.Tagline,
	)
	return i, err
}

const insertWatched = `-- name: InsertWatched :one
INSERT INTO
    watched (movie_id, watched_date)
VALUES
    (?, ?)
RETURNING
    movie_id, watched_date
`

type InsertWatchedParams struct {
	MovieID     int64
	WatchedDate time.Time
}

func (q *Queries) InsertWatched(ctx context.Context, arg InsertWatchedParams) (Watched, error) {
	row := q.db.QueryRowContext(ctx, insertWatched, arg.MovieID, arg.WatchedDate)
	var i Watched
	err := row.Scan(&i.MovieID, &i.WatchedDate)
	return i, err
}
