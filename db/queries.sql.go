// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"time"
)

const getAllMovies = `-- name: GetAllMovies :many
SELECT
    id, imdb_id, title, release_date, original_language, overview, poster_path, budget, revenue, runtime, vote_average
FROM
    movie
`

func (q *Queries) GetAllMovies(ctx context.Context) ([]Movie, error) {
	rows, err := q.db.QueryContext(ctx, getAllMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.ImdbID,
			&i.Title,
			&i.ReleaseDate,
			&i.OriginalLanguage,
			&i.Overview,
			&i.PosterPath,
			&i.Budget,
			&i.Revenue,
			&i.Runtime,
			&i.VoteAverage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWatched = `-- name: GetAllWatched :many
SELECT
    movie_id, watched_date
FROM
    watched
`

func (q *Queries) GetAllWatched(ctx context.Context) ([]Watched, error) {
	rows, err := q.db.QueryContext(ctx, getAllWatched)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Watched
	for rows.Next() {
		var i Watched
		if err := rows.Scan(&i.MovieID, &i.WatchedDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostWatchedMovies = `-- name: GetMostWatchedMovies :many
SELECT
    movie.id, movie.imdb_id, movie.title, movie.release_date, movie.original_language, movie.overview, movie.poster_path, movie.budget, movie.revenue, movie.runtime, movie.vote_average,
    COUNT(*) AS view_count
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
GROUP BY
    movie.id
ORDER BY
    view_count DESC
`

type GetMostWatchedMoviesRow struct {
	ID               int64
	ImdbID           *string
	Title            string
	ReleaseDate      time.Time
	OriginalLanguage string
	Overview         string
	PosterPath       string
	Budget           int64
	Revenue          int64
	Runtime          int64
	VoteAverage      float64
	ViewCount        int64
}

func (q *Queries) GetMostWatchedMovies(ctx context.Context) ([]GetMostWatchedMoviesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostWatchedMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostWatchedMoviesRow
	for rows.Next() {
		var i GetMostWatchedMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.ImdbID,
			&i.Title,
			&i.ReleaseDate,
			&i.OriginalLanguage,
			&i.Overview,
			&i.PosterPath,
			&i.Budget,
			&i.Revenue,
			&i.Runtime,
			&i.VoteAverage,
			&i.ViewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieFromName = `-- name: GetMovieFromName :one
SELECT
    id, imdb_id, title, release_date, original_language, overview, poster_path, budget, revenue, runtime, vote_average
FROM
    movie
WHERE
    title = ?
`

func (q *Queries) GetMovieFromName(ctx context.Context, title string) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieFromName, title)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.ImdbID,
		&i.Title,
		&i.ReleaseDate,
		&i.OriginalLanguage,
		&i.Overview,
		&i.PosterPath,
		&i.Budget,
		&i.Revenue,
		&i.Runtime,
		&i.VoteAverage,
	)
	return i, err
}

const getMovieFromReference = `-- name: GetMovieFromReference :one
SELECT
    id, imdb_id, title, release_date, original_language, overview, poster_path, budget, revenue, runtime, vote_average
FROM
    movie
WHERE
    id = ?
`

func (q *Queries) GetMovieFromReference(ctx context.Context, id int64) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieFromReference, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.ImdbID,
		&i.Title,
		&i.ReleaseDate,
		&i.OriginalLanguage,
		&i.Overview,
		&i.PosterPath,
		&i.Budget,
		&i.Revenue,
		&i.Runtime,
		&i.VoteAverage,
	)
	return i, err
}

const getWatchedJoinMovie = `-- name: GetWatchedJoinMovie :many
SELECT
    movie_id, watched_date, id, imdb_id, title, release_date, original_language, overview, poster_path, budget, revenue, runtime, vote_average
FROM
    watched
    JOIN movie ON watched.movie_id = movie.id
`

type GetWatchedJoinMovieRow struct {
	MovieID          int64
	WatchedDate      time.Time
	ID               int64
	ImdbID           *string
	Title            string
	ReleaseDate      time.Time
	OriginalLanguage string
	Overview         string
	PosterPath       string
	Budget           int64
	Revenue          int64
	Runtime          int64
	VoteAverage      float64
}

func (q *Queries) GetWatchedJoinMovie(ctx context.Context) ([]GetWatchedJoinMovieRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchedJoinMovie)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchedJoinMovieRow
	for rows.Next() {
		var i GetWatchedJoinMovieRow
		if err := rows.Scan(
			&i.MovieID,
			&i.WatchedDate,
			&i.ID,
			&i.ImdbID,
			&i.Title,
			&i.ReleaseDate,
			&i.OriginalLanguage,
			&i.Overview,
			&i.PosterPath,
			&i.Budget,
			&i.Revenue,
			&i.Runtime,
			&i.VoteAverage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMovie = `-- name: InsertMovie :one
INSERT INTO
    movie (
        id,
        imdb_id,
        title,
        original_language,
        overview,
        poster_path,
        release_date,
        budget,
        revenue,
        runtime,
        vote_average
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING
    id, imdb_id, title, release_date, original_language, overview, poster_path, budget, revenue, runtime, vote_average
`

type InsertMovieParams struct {
	ID               int64
	ImdbID           *string
	Title            string
	OriginalLanguage string
	Overview         string
	PosterPath       string
	ReleaseDate      time.Time
	Budget           int64
	Revenue          int64
	Runtime          int64
	VoteAverage      float64
}

func (q *Queries) InsertMovie(ctx context.Context, arg InsertMovieParams) (Movie, error) {
	row := q.db.QueryRowContext(ctx, insertMovie,
		arg.ID,
		arg.ImdbID,
		arg.Title,
		arg.OriginalLanguage,
		arg.Overview,
		arg.PosterPath,
		arg.ReleaseDate,
		arg.Budget,
		arg.Revenue,
		arg.Runtime,
		arg.VoteAverage,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.ImdbID,
		&i.Title,
		&i.ReleaseDate,
		&i.OriginalLanguage,
		&i.Overview,
		&i.PosterPath,
		&i.Budget,
		&i.Revenue,
		&i.Runtime,
		&i.VoteAverage,
	)
	return i, err
}

const insertWatched = `-- name: InsertWatched :one
INSERT INTO
    watched (movie_id, watched_date)
VALUES
    (?, ?)
RETURNING
    movie_id, watched_date
`

type InsertWatchedParams struct {
	MovieID     int64
	WatchedDate time.Time
}

func (q *Queries) InsertWatched(ctx context.Context, arg InsertWatchedParams) (Watched, error) {
	row := q.db.QueryRowContext(ctx, insertWatched, arg.MovieID, arg.WatchedDate)
	var i Watched
	err := row.Scan(&i.MovieID, &i.WatchedDate)
	return i, err
}
