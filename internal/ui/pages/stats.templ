package pages

import (
	"fmt"
	"gowatch/internal/models"
	"gowatch/internal/ui/components/moviecard"
	"gowatch/internal/ui/templui/avatar"
	"gowatch/internal/ui/templui/card"
	"gowatch/internal/ui/templui/chart"
	"gowatch/internal/ui/templui/icon"
	"gowatch/internal/ui/templui/selectbox"
	"gowatch/internal/ui/templui/skeleton"
	"strconv"
	"strings"
	"time"
)

// getGenreColors returns the shared genre color palette
func getGenreColors() []any {
	return []any{
		"rgba(59, 130, 246, 0.8)", // Blue
		"rgba(16, 185, 129, 0.8)", // Green
		"rgba(245, 158, 11, 0.8)", // Yellow
		"rgba(239, 68, 68, 0.8)",  // Red
		"rgba(139, 92, 246, 0.8)", // Purple
		"rgba(236, 72, 153, 0.8)", // Pink (Others)
	}
}

// getGenreBorderColors returns the shared genre border color palette
func getGenreBorderColors() []any {
	return []any{
		"rgba(59, 130, 246, 1)", // Blue
		"rgba(16, 185, 129, 1)", // Green
		"rgba(245, 158, 11, 1)", // Yellow
		"rgba(239, 68, 68, 1)",  // Red
		"rgba(139, 92, 246, 1)", // Purple
		"rgba(236, 72, 153, 1)", // Pink (Others)
	}
}

templ Stats(stats *models.WatchedStats, limit int) {
	@Layout() {
		@templ.Fragment("content") {
			<div class="space-y-8 pb-5">
				@statsHeader()
				@statsMetrics(stats)
				@statsCharts(stats)
				@topListsSection(limit)
			</div>
		}
	}
}

templ topListsSection(limit int) {
	<div class="space-y-8">
		<div>
			<h2 class="flex items-center justify-between mb-2">
				<div class="flex flex-row items-center gap-2 text-xl font-semibold">
					@icon.Star(icon.Props{
						Size: 20,
					})
					Top Lists
				</div>
				<form hx-get="/htmx/stats/top-lists" hx-target="#top-lists" hx-trigger="change">
					@selectbox.SelectBox(selectbox.Props{
						Attributes: templ.Attributes{},
					}) {
						@selectbox.Trigger(selectbox.TriggerProps{
							Name: "limit",
						}) {
							@selectbox.Value(selectbox.ValueProps{
								Placeholder: "Select number of items",
							})
						}
						@selectbox.Content(selectbox.ContentProps{
							NoSearch: true,
						}) {
							@selectbox.Item(selectbox.ItemProps{
								Value:    "5",
								Selected: limit == 5,
							}) {
								5 
							}
							@selectbox.Item(selectbox.ItemProps{
								Value:    "10",
								Selected: limit == 10,
							}) {
								10 
							}
							@selectbox.Item(selectbox.ItemProps{
								Value:    "15",
								Selected: limit == 15,
							}) {
								15 
							}
							@selectbox.Item(selectbox.ItemProps{
								Value:    "20",
								Selected: limit == 20,
							}) {
								20 
							}
						}
					}
				</form>
			</h2>
			<div id="top-lists" hx-get={ templ.SafeURL(fmt.Sprintf("/htmx/stats/top-lists?limit=%d", limit)) } hx-trigger="load"></div>
		</div>
	</div>
}

templ TopLists(stats *models.WatchedStats, limit int) {
	<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
		@topMoviesCard(stats.MostWatchedMovies, limit)
		@topActorsCard("Most Watched Male Actors", int64(2), stats.MostWatchedActors, limit)
		@topActorsCard("Most Watched Female Actors", int64(1), stats.MostWatchedActors, limit)
	</div>
}

templ topMoviesCard(movies []models.TopMovie, limit int) {
	@card.Card() {
		@card.Header() {
			@card.Title() {
				Most Watched Movies
			}
		}
		@card.Content() {
			if len(movies) > 0 {
				<div class="flex flex-wrap gap-4">
					for i, movie := range movies {
						if i >= limit {
							{{ break }}
						}
						@moviecard.MovieCard(moviecard.Props{
							Title:      movie.Title,
							PosterPath: "/" + strings.TrimPrefix(movie.PosterPath, "/"),
							Href:       "/movie/" + strconv.Itoa(int(movie.ID)),
							Hoverable:  true,
						}) {
							<div class="text-center text-white font-semibold">{ movie.WatchCount } watches</div>
						}
					}
				</div>
			} else {
				<div class="text-center text-muted-foreground py-8">No data available</div>
			}
		}
	}
}

templ topActorsCard(title string, gender int64, actors []models.TopActor, limit int) {
	@card.Card() {
		@card.Header() {
			@card.Title() {
				{ title }
			}
		}
		@card.Content() {
			{{ count := 0 }}
			for _, actor := range actors {
				if actor.Gender == gender && count < limit {
					{{ count++ }}
				}
			}
			if count > 0 {
				<div class="space-y-3">
					{{ count = 0 }}
					for _, actor := range actors {
						if actor.Gender == gender && count < limit {
							<div class="flex items-center gap-3">
								@avatar.Avatar() {
									if actor.ProfilePath != "" {
										@avatar.Image(avatar.ImageProps{
											Src:   "https://image.tmdb.org/t/p/w185/" + strings.TrimPrefix(actor.ProfilePath, "/"),
											Alt:   actor.Name,
											Class: "object-cover",
										})
									} else {
										@avatar.Fallback() {
											{ string(actor.Name[0]) }
										}
									}
								}
								<div class="flex-1">
									<div class="font-medium text-sm">{ actor.Name }</div>
									<div class="text-xs text-muted-foreground">{ fmt.Sprintf("%d watches", actor.WatchCount) }</div>
								</div>
							</div>
							{{ count++ }}
						}
					}
				</div>
			} else {
				<div class="text-center text-muted-foreground py-8">No data available</div>
			}
		}
	}
}

templ statsHeader() {
	<div class="space-y-4">
		<h1 class="text-2xl sm:text-3xl font-bold">Statistics</h1>
		<p class="text-muted-foreground text-sm sm:text-base max-w-2xl">
			Overview of your movie watching habits and preferences.
		</p>
	</div>
}

templ statsMetrics(stats *models.WatchedStats) {
	@card.Card() {
		@card.Content() {
			<div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-5 gap-4">
				@statsMetricCard("Total Watched", fmt.Sprintf("%d", stats.TotalWatched), icon.Film)
				@statsMetricCard("Avg per Day", fmt.Sprintf("%.1f", stats.AvgPerDay), icon.Calendar)
				@statsMetricCard("Avg per Week", fmt.Sprintf("%.1f", stats.AvgPerWeek), icon.ChartBar)
				@statsMetricCard("Avg per Month", fmt.Sprintf("%.1f", stats.AvgPerMonth), icon.TrendingUp)
				if stats.MostWatchedDay != nil {
					@statsMetricCard("Most Watched Day", stats.MostWatchedDay.Date.Format("2 of January 2006"), icon.Calendar)
				} else {
					@statsMetricCard("Most Watched Day", "No data", icon.Calendar)
				}
			</div>
		}
	}
	@statsTimeMetrics(stats)
}

templ statsTimeMetrics(stats *models.WatchedStats) {
	@card.Card() {
		@card.Content() {
			<div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
				@statsMetricCard("Total Hours", fmt.Sprintf("%.1f hours", stats.TotalHoursWatched), icon.Clock)
				@statsMetricCard("Avg Hours/Day", fmt.Sprintf("%.1f", stats.AvgHoursPerDay), icon.Clock)
				@statsMetricCard("Avg Hours/Week", fmt.Sprintf("%.1f", stats.AvgHoursPerWeek), icon.Clock)
				@statsMetricCard("Avg Hours/Month", fmt.Sprintf("%.1f", stats.AvgHoursPerMonth), icon.Clock)
			</div>
		}
	}
}

templ statsMetricCard(label, value string, iconFunc func(...icon.Props) templ.Component) {
	<div>
		<div class="text-center">
			<div class="flex items-center justify-center mb-2">
				@iconFunc(icon.Props{Size: 24, Class: "text-primary"})
			</div>
			<div class="text-2xl font-bold text-primary">{ value }</div>
			<div class="text-xs text-muted-foreground">{ label }</div>
		</div>
	</div>
}

templ statsCharts(stats *models.WatchedStats) {
	<div class="space-y-8">
		<div>
			<h2 class="text-xl font-semibold flex items-center gap-2">
				@icon.ChartBar(icon.Props{Size: 20})
				Distribution
			</h2>
		</div>
		<div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
			@card.Card() {
				@card.Header() {
					@card.Title() {
						Genres
					}
				}
				@card.Content() {
					@chart.Chart(chart.Props{
						Variant:    chart.VariantPie,
						Data:       prepareGenresData(stats.Genres),
						Options:    chart.Options{Responsive: true, Legend: true},
						ShowLegend: true,
					})
				}
			}
			@card.Card() {
				@card.Header() {
					@card.Title() {
						Movies per Month
					}
				}
				@card.Content() {
					@chart.Chart(chart.Props{
						Variant:     chart.VariantBar,
						Data:        prepareMonthlyMoviesData(stats.MonthlyLastYear),
						Options:     chart.Options{Responsive: true},
						ShowXAxis:   true,
						ShowXLabels: true,
						ShowYAxis:   true,
						ShowYLabels: true,
						Class:       "h-50",
					})
					// Trend indicator below chart
					<div class="mt-8 flex items-center justify-center gap-2 text-md">
						switch stats.MonthlyMoviesTrendDirection {
							case models.TrendUp:
								@icon.TrendingUp(icon.Props{Size: 16, Class: "text-green-500"})
								<span class="text-green-500">+{ stats.MonthlyMoviesTrendValue }</span> movies this month
							case models.TrendDown:
								@icon.TrendingDown(icon.Props{Size: 16, Class: "text-red-500"})
								<span class="text-red-500">{ stats.MonthlyMoviesTrendValue }</span> movies this month
							default:
								<span class="text-muted-foreground">{ stats.MonthlyMoviesTrendValue }</span> movies this month
						}
					</div>
				}
			}
			@card.Card() {
				@card.Header() {
					@card.Title() {
						Theater vs Home
					}
				}
				@card.Content() {
					@chart.Chart(chart.Props{
						Variant:    chart.VariantPie,
						Data:       prepareTheaterData(stats.TheaterVsHome),
						Options:    chart.Options{Responsive: true, Legend: true},
						ShowLegend: true,
					})
				}
			}
			@card.Card() {
				@card.Header() {
					@card.Title() {
						Hours per Month 
					}
				}
				@card.Content() {
					@chart.Chart(chart.Props{
						Variant:     chart.VariantBar,
						Data:        prepareMonthlyHoursData(stats.MonthlyHoursLastYear),
						Options:     chart.Options{Responsive: true},
						ShowXAxis:   true,
						ShowXLabels: true,
						ShowYAxis:   true,
						ShowYLabels: true,
						Class:       "h-50",
					})
					// Trend indicator below chart
					<div class="mt-8 flex items-center justify-center gap-2 text-md">
						switch stats.MonthlyHoursTrendDirection {
							case models.TrendUp:
								@icon.TrendingUp(icon.Props{Size: 16, Class: "text-green-500"})
								<span class="text-green-500">+{ fmt.Sprintf("%.1f", stats.MonthlyHoursTrendValue) }</span> hours this month
							case models.TrendDown:
								@icon.TrendingDown(icon.Props{Size: 16, Class: "text-red-500"})
								<span class="text-red-500">{ fmt.Sprintf("%.1f", stats.MonthlyHoursTrendValue) }</span> hours this month
							default:
								<span class="text-muted-foreground">{ fmt.Sprintf("%.1f", stats.MonthlyHoursTrendValue) }</span> hours this month
						}
					</div>
				}
			}
		</div>
		<div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
			@card.Card() {
				@card.Header() {
					@card.Title() {
						Weekday Distribution
					}
				}
				@card.Content() {
					@chart.Chart(chart.Props{
						Variant:     chart.VariantBar,
						Data:        prepareWeekdayData(stats.WeekdayDistribution),
						Options:     chart.Options{Responsive: true},
						ShowXAxis:   true,
						ShowXLabels: true,
						ShowYAxis:   true,
						ShowYLabels: true,
						Class:       "h-80",
					})
				}
			}
			@card.Card() {
				@card.Header() {
					@card.Title() {
						Genres by Month 
					}
				}
				@card.Content() {
					@chart.Chart(chart.Props{
						Variant:     chart.VariantBar,
						Stacked:     true,
						ShowLegend:  true,
						ShowYGrid:   true,
						ShowXLabels: true,
						Data:        prepareGenresByMonthData(stats.MonthlyGenreBreakdown),
						Class:       "h-80",
					})
				}
			}
		</div>
	</div>
}

// Helper functions to prepare chart data
func prepareMonthlyData(data []models.PeriodCount) chart.Data {
	// Create a map of period to count
	dataMap := make(map[string]int64)
	for _, pc := range data {
		dataMap[pc.Period] = pc.Count
	}

	// Generate last 12 complete months
	now := time.Now()
	labels := make([]string, 12)
	values := make([]float64, 12)
	for i := 12; i >= 1; i-- {
		month := now.AddDate(0, -i, 0)
		period := month.Format("2006-01")
		labels[12-i] = period
		values[12-i] = float64(dataMap[period])
	}

	return chart.Data{
		Labels: labels,
		Datasets: []chart.Dataset{{
			Label:           "Watches",
			Data:            values,
			BackgroundColor: []any{"rgba(59, 130, 246, 0.5)"},
			BorderColor:     []any{"rgba(59, 130, 246, 1)"},
			BorderWidth:     1,
		}},
	}
}

func prepareGenresByMonthData(data []models.MonthlyGenreBreakdown) chart.Data {
	if len(data) == 0 {
		return chart.Data{}
	}

	// Collect all unique genres across all months
	genreSet := make(map[string]bool)
	for _, month := range data {
		for genre := range month.Genres {
			genreSet[genre] = true
		}
	}

	// Convert to slice (order will be consistent due to map iteration)
	var genres []string
	for genre := range genreSet {
		genres = append(genres, genre)
	}

	// Use shared genre colors
	colorPalette := getGenreColors()
	borderPalette := getGenreBorderColors()

	// Create month -> genre data mapping (data is already sorted by month from DB)
	monthData := make(map[string]map[string]int)
	var months []string
	var labels []string
	for _, month := range data {
		monthData[month.Month] = month.Genres
		months = append(months, month.Month)
		// Parse YYYY-MM and format as abbreviated month name
		if parsedTime, err := time.Parse("2006-01", month.Month); err == nil {
			labels = append(labels, parsedTime.Format("Jan"))
		} else {
			labels = append(labels, month.Month) // fallback
		}
	}

	// Create datasets for each genre
	var datasets []chart.Dataset
	for i, genre := range genres {
		var values []float64
		for _, month := range months {
			if genreCounts, exists := monthData[month]; exists {
				if count, hasGenre := genreCounts[genre]; hasGenre {
					values = append(values, float64(count))
				} else {
					values = append(values, 0)
				}
			}
		}

		colorIndex := i % len(colorPalette)
		datasets = append(datasets, chart.Dataset{
			Label:           genre,
			Data:            values,
			BackgroundColor: []any{colorPalette[colorIndex]},
			BorderColor:     []any{borderPalette[colorIndex]},
			BorderWidth:     1,
		})
	}

	return chart.Data{
		Labels:   labels,
		Datasets: datasets,
	}
}

func prepareYearlyData(data []models.PeriodCount) chart.Data {
	labels := make([]string, len(data))
	values := make([]float64, len(data))
	for i, pc := range data {
		labels[i] = pc.Period
		values[i] = float64(pc.Count)
	}
	return chart.Data{
		Labels: labels,
		Datasets: []chart.Dataset{{
			Label:           "Watches",
			Data:            values,
			Tension:         0.4,
			BorderColor:     []any{"rgba(16, 185, 129, 1)"},
			BackgroundColor: []any{"rgba(16, 185, 129, 0.1)"},
			Fill:            true,
		}},
	}
}

func prepareGenresData(data []models.GenreCount) chart.Data {
	labels := make([]string, len(data))
	values := make([]float64, len(data))
	colors := getGenreColors()
	for i, gc := range data {
		labels[i] = gc.Name
		values[i] = float64(gc.Count)
	}
	return chart.Data{
		Labels: labels,
		Datasets: []chart.Dataset{{
			Label:           "Movies",
			Data:            values,
			BackgroundColor: colors,
		}},
	}
}

func prepareTheaterData(data []models.TheaterCount) chart.Data {
	labels := make([]string, len(data))
	values := make([]float64, len(data))
	colors := []any{
		"rgba(59, 130, 246, 0.8)", // Theater
		"rgba(16, 185, 129, 0.8)", // Home
	}
	for i, tc := range data {
		if tc.InTheater {
			labels[i] = "Theater"
		} else {
			labels[i] = "Home"
		}
		values[i] = float64(tc.Count)
	}
	return chart.Data{
		Labels: labels,
		Datasets: []chart.Dataset{{
			Label:           "Watches",
			Data:            values,
			BackgroundColor: colors,
		}},
	}
}

func prepareMonthlyMoviesData(data []models.PeriodCount) chart.Data {
	// Create a map of period to count
	dataMap := make(map[string]int64)
	for _, pc := range data {
		dataMap[pc.Period] = pc.Count
	}

	// Generate last 12 complete months
	now := time.Now()
	labels := make([]string, 12)
	values := make([]float64, 12)
	for i := 11; i >= 0; i-- {
		month := now.AddDate(0, -i, 0)
		period := month.Format("2006-01")
		label := month.Format("Jan")
		labels[11-i] = label
		values[11-i] = float64(dataMap[period])
	}

	return chart.Data{
		Labels: labels,
		Datasets: []chart.Dataset{{
			Label:           "Movies",
			Data:            values,
			BackgroundColor: []any{"rgba(59, 130, 246, 0.5)"}, // Blue theme
			BorderColor:     []any{"rgba(59, 130, 246, 1)"},   // Blue theme
			BorderWidth:     1,
		}},
	}
}

func prepareWeekdayData(data []models.PeriodCount) chart.Data {
	labels := make([]string, len(data))
	values := make([]float64, len(data))
	for i, pc := range data {
		labels[i] = pc.Period
		values[i] = float64(pc.Count)
	}
	return chart.Data{
		Labels: labels,
		Datasets: []chart.Dataset{{
			Label:           "Watches",
			Data:            values,
			BackgroundColor: []any{"rgba(139, 92, 246, 0.5)"},
			BorderColor:     []any{"rgba(139, 92, 246, 1)"},
			BorderWidth:     1,
		}},
	}
}

func prepareMonthlyHoursData(data []models.PeriodHours) chart.Data {
	// Create a map of period to hours
	dataMap := make(map[string]float64)
	for _, ph := range data {
		dataMap[ph.Period] = ph.Hours
	}

	// Generate last 12 complete months
	now := time.Now()
	labels := make([]string, 12)
	values := make([]float64, 12)
	for i := 11; i >= 0; i-- {
		month := now.AddDate(0, -i, 0)
		period := month.Format("2006-01")
		label := month.Format("Jan")
		labels[11-i] = label
		values[11-i] = float64(dataMap[period])
	}

	return chart.Data{
		Labels: labels,
		Datasets: []chart.Dataset{{
			Label:           "Hours",
			Data:            values,
			BackgroundColor: []any{"rgba(245, 158, 11, 0.5)"},
			BorderColor:     []any{"rgba(245, 158, 11, 1)"},
			BorderWidth:     1,
		}},
	}
}

templ StatsLoading() {
	<div id="stats-loading" class="htmx-indicator absolute inset-0 bg-background z-5 pointer-events-none overflow-hidden">
		<div class="p-4 space-y-8">
			// Page title
			<div class="space-y-6">
				@skeleton.Skeleton(skeleton.Props{Class: "h-12 w-48 rounded-lg"})
				@skeleton.Skeleton(skeleton.Props{Class: "h-4 w-64 rounded-lg"})
			</div>
			// Stats charts
			@skeleton.Skeleton(skeleton.Props{Class: "h-32 w-full mb-4 rounded-lg"})
			<div class="flex flex-col mt-8 space-y-8">
				for _ = range 4 {
					@skeleton.Skeleton(skeleton.Props{Class: "h-6 w-32 mb-4 rounded-lg"})
					<div class="flex flex-row space-x-8">
						@skeleton.Skeleton(skeleton.Props{Class: "h-48 w-full rounded-lg"})
						@skeleton.Skeleton(skeleton.Props{Class: "h-48 w-full rounded-lg"})
					</div>
				}
			</div>
		</div>
	</div>
}
